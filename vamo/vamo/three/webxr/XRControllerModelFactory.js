import{Mesh,MeshBasicMaterial,Object3D,SphereGeometry}from"../three.module.js";import{GLTFLoader}from"../loaders/GLTFLoader.js";import{Constants as MotionControllerConstants,fetchProfile,MotionController}from"../libs/motion-controllers.module.js";const DEFAULT_PROFILES_PATH="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",DEFAULT_PROFILE="generic-trigger";class XRControllerModel extends Object3D{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap!=e&&(this.envMap=e,this.traverse(e=>{e.isMesh&&(e.material.envMap=this.envMap,e.material.needsUpdate=!0)})),this}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach(e=>{Object.values(e.visualResponses).forEach(e=>{var{valueNode:e,minNode:o,maxNode:t,value:n,valueNodeProperty:r}=e;e&&(r===MotionControllerConstants.VisualResponseProperty.VISIBILITY?e.visible=n:r===MotionControllerConstants.VisualResponseProperty.TRANSFORM&&(e.quaternion.slerpQuaternions(o.quaternion,t.quaternion,n),e.position.lerpVectors(o.position,t.position,n)))})}))}}function findNodes(e,s){Object.values(e.components).forEach(e=>{var{type:o,touchPointNodeName:t,visualResponses:n}=e;o===MotionControllerConstants.ComponentType.TOUCHPAD&&(e.touchPointNode=s.getObjectByName(t),e.touchPointNode?(o=new SphereGeometry(.001),t=new MeshBasicMaterial({color:255}),o=new Mesh(o,t),e.touchPointNode.add(o)):console.warn(`Could not find touch dot, ${e.touchPointNodeName}, in touchpad component `+e.id)),Object.values(n).forEach(e=>{var{valueNodeName:o,minNodeName:t,maxNodeName:n,valueNodeProperty:r}=e;if(r===MotionControllerConstants.VisualResponseProperty.TRANSFORM){if(e.minNode=s.getObjectByName(t),e.maxNode=s.getObjectByName(n),!e.minNode)return void console.warn(`Could not find ${t} in the model`);if(!e.maxNode)return void console.warn(`Could not find ${n} in the model`)}e.valueNode=s.getObjectByName(o),e.valueNode||console.warn(`Could not find ${o} in the model`)})})}function addAssetSceneToControllerModel(o,e){findNodes(o.motionController,e),o.envMap&&e.traverse(e=>{e.isMesh&&(e.material.envMap=o.envMap,e.material.needsUpdate=!0)}),o.add(e)}class XRControllerModelFactory{constructor(e=null){this.gltfLoader=e,this.path=DEFAULT_PROFILES_PATH,this._assetCache={},this.gltfLoader||(this.gltfLoader=new GLTFLoader)}createControllerModel(e){const n=new XRControllerModel;let r=null;return e.addEventListener("connected",e=>{const t=e.data;"tracked-pointer"===t.targetRayMode&&t.gamepad&&fetchProfile(t,this.path,DEFAULT_PROFILE).then(({profile:e,assetPath:o})=>{n.motionController=new MotionController(t,e,o);e=this._assetCache[n.motionController.assetUrl];if(e)r=e.scene.clone(),addAssetSceneToControllerModel(n,r);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(n.motionController.assetUrl,e=>{this._assetCache[n.motionController.assetUrl]=e,r=e.scene.clone(),addAssetSceneToControllerModel(n,r)},null,()=>{throw new Error(`Asset ${n.motionController.assetUrl} missing or malformed.`)})}}).catch(e=>{console.warn(e)})}),e.addEventListener("disconnected",()=>{n.motionController=null,n.remove(r),r=null}),n}}export{XRControllerModelFactory};